// __START_OF_LICENSE__
// 
// Copyright (c) 2019 Jun Luo
// All rights reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 3,
// or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this program; see the file LICENSE.  If not,
// see <http://www.gnu.org/licenses/>.
// 
// __END_OF_LICENSE__

#ifndef util_hpp
#define util_hpp

#include <algorithm>
#include <random>
#include <set>

#include <SPL/Array2.hpp>
#include <SPL/Sequence1.hpp>
#include <boost/math/constants/constants.hpp>

// define pi
const double pi = boost::math::constants::pi<double>();

/*!
@brief  The smooth operator options.
@detail
This contains all the smoothing operators.
"binomial" is the binomial filter
"mean" is the mean filter
*/
enum class Smooth_operator {
  binomial,
  mean
};

/*!
@brief  The smooth direction options
@detail
This contains all the smoothing direciton options.
"orthogonal" means only smooth the orthogonal direction when computing partial derivatives.
"both" means smooth on both horizontal and vertical directions when computing
 partial derivatives.
*/
enum class Smooth_direction {
  orthogonal,
  both
};

/*!
@brief  The smoothing options
@detail
This is a struct that contains all the smoothing options.

smooth_order_ is the order of the smoothing filter.

NOTE: The bound_policy_ options are consistent with the ConvolveMode options in
SPL library. Please use the ConvolveMode options in SPL library to set the
value of bound_policy_.
*/
struct Smooth_options {
  int bound_policy_;
  int smooth_order_;
  Smooth_operator smooth_operator_;
  Smooth_direction smooth_direction_;
};

/*!
@brief  Convert from the precision to the max_value.
@details
This is a helper function for the Image class to convert
from the precision (bits/sample) to the maximum value of the image.
*/
int precision_to_value(int prec);

/*!
@brief  Convert from a value to its precision.
@details
This is a helper function for the Image class to convert from the
maximum value of the image to the precision (bits/sample).
*/
int value_to_precision(int value);

/*!
@brief  Random shuffle elements in a sequence from begin to end
@tparam  I The iterator type

@param begin
Random-access iterator that points to the begin position of the
sequence to be shuffled.
@param end
Random-access iterator that points to the end position of the
sequence to be shuffled.
@param seed
The seed to be used for the random number generator engine.

@details
This will random shuffle elements in a sequence.
This function used mt19937 generator engine.

The seed determines how the random number generator engine works.
If the seed is a fixed value every time we run the program, 
the order of the shuffled sequence will always be the same.
If the seed various (e.g generated by std::random_device) every
time we run the program, the order of the shuffled sequence will
be different for every time.
*/
template <class I>
void random_shuffle(I begin, I end, unsigned int seed);

/*!
@brief  Generate a random number within the specified range.
@tparam T  The value type.

@param lower_bound  The lower bound of the random number.
@param upper_bound  The upper bound of the random number.
@param seed  The seed to be used for the random number generator engine.
@return  The generated random number.
*/
template <typename T>
T generate_random_number(T lower_bound, T upper_bound, unsigned int seed);

/*!
@brief  Call funciton for each face inside a region of a triangulation.
@tparam T  The triangulation type.
@tparam F
A functor/function to do additional operation on the visited face.

@param tri  The triangulation.
@param border_edges
The set of halfedges incident on border of region whose faces are to be visited.
@param func
The functor/function which helpes to do any additional operation to the visited face.

@details
This function is used to help visiting all new faces inside a region
once a vertex is deleted from the triangulation.

The region surrounded by s must be an enclosed region.
WARNING: for efficiency concern border_edges is passed by reference, the
algorithm will keep insert/erase elements in s, and finally s will become
empty once all faces are visited inside the region.

The type F has the following signature:
<ul>
     <li>void visit_face(T::Face_handle face)
<\ul>
This can be used to do any additional operation to the visited face.
(i.e update face error)
*/
template <class T, class F>
void for_each_face_in_region(
  T& tri, std::set<typename T::Halfedge_handle>& border_edges, F func);

/*!
@brief  Get a binomial filter.
@param smooth_order  The smooth order of the binomial filter.
@param result_filter  A 1-D sequence to store the result binomial filter.
@details
This function gets a 1-D sequence that represents a n-order binomial filter.

Note: The smooth_order should be an odd number.
      If one, no smoothing will be applied.
*/
void get_binomial_filter(int smooth_order, SPL::RealSequence1& result_filter);

/*!
@brief  Get a mean filter.
@param smooth_order  The smooth order of the mean filter.
@param result_filter  A 1-D sequence to store the result mean filter.
@details
This function gets a 1-D sequence that represents a n-order mean filter.

Note: The smooth_order should be an odd number.
      If one, no smoothing will be applied.
*/
void get_mean_filter(int smooth_order, SPL::RealSequence1& result_filter);

/*!
@brief  Get the smooth filter.
@param smooth_order  The smooth order of the smoothing filter.
@param smooth_operator  The smoothing operator.
@param result_filter  A 1-D sequence to store the result smoothing filter.
@details
This function will call get_binomial_filter and get_mean_filter function
to get the smoothing filter.
*/
void get_smooth_filter(int smooth_order, Smooth_operator smooth_operator,
                       SPL::RealSequence1& result_filter);

/*!
@brief  Get the derivative filter.
@param x_order  The order of the x direction.
@param y_order  The order of the y direction.
@param horz_filter
A 1-D sequence to store the horizontal filter of the derivative filter.
@param vert_filter
A 1-D sequence to store the vertical filter of the derivative filter.

@detail
This function may throw invalid_argument exception if the specified 
combination of x_order and y_order is not supported.

Currently, the following combinations of x_order and y_order are supported:
x_order = 1, y_order = 0;    // fx
x_order = 0, y_order = 1;    // fy
x_order = 1, y_order = 1;    // fxy
x_order = 2, y_order = 0;    // fxx
x_order = 0, y_order = 2;    // fyy
*/
void get_derivative_filter(int x_order, int y_order, SPL::RealSequence1& horz_filter,
                          SPL::RealSequence1& vert_filter);

/*!
@brief  Get the smoothing and derivative filters.
@param x_order  The order of the x direction.
@param y_order  The order of the y direction.
@param smooth_options  The smoothing options.
@param horz_smooth_filter
A 1-d sequence to store the horizontal filter of the smoothing filter.
@param vert_smooth_filter
A 1-d sequence to store the vertical filter of the smoothing filter.
@param horz_deriv_filter
A 1-d sequence to store the horizontal filter of the derivative filter.
@param vert_deriv_filter
A 1-d sequence to store the vertical filter of the derivative filter.

@detail
This function can help to get the horizontal and vertical filters of the
smoothing filter and derivative filter for the specified x_order, y_order
and smoothing options. It will basically call function get_smooth_filter
and get_derivative_filter internally.
*/
void get_smoothing_and_derivative_filters(int x_order, int y_order,
                                         const Smooth_options& smooth_options,
                                         SPL::RealSequence1& horz_smooth_filter,
                                         SPL::RealSequence1& vert_smooth_filter,
                                         SPL::RealSequence1& horz_deriv_filter,
                                         SPL::RealSequence1& vert_deriv_filter);

/*!
@brief  Smooth an image with the specificied smoothing options.
@param input  A 2D array representing the input image.
@param smooth_options  The smoothing options.
@param result  The result smoothed image.
*/
void get_smoothed_image(const SPL::Array2<double>& input,
                        const Smooth_options& smooth_options,
                        SPL::Array2<double>& result);




/*!
@brief  Get the partial derivative of the input 2-D array.
@param input  A 2-d array containing the input image data.
@param x_order  The x order of the partial derivative.
@param y_order  The y order of the partial derivative.
@param derivative_bound_policy
The boundary handling policy while convoling with the derivative filters.
@param smooth_options  The smoothing options.
@param use_double_convolution
A boolean value to indicate if to se double convolution or not.
@param result  A 2-d array containing the result partial derivative.

@detail
This function is used to get the partial derivatives of an image.
Internally, it will convolve the 2-D array with the smoothing filter
and the derivative filter.

If the parameter use_double_convolution is true, it will do image smoothing and
partial derivative operations seperately in two convolutions (i.e., smooth the
image in the first convolution, then compute partial derivatve in the second convolution).
If false, it will combine smooth filter and derivative filter and produce a
horzontal filter and a vertical filter first, and then do all in one convolution.
*/
void get_smoothed_derivative(const SPL::Array2<double>& input, int x_order, int y_order,
                      int derivative_bound_policy, const Smooth_options& smooth_options,
                      bool use_double_convolution, SPL::Array2<double>& result);



/*!
@brief  Get the mmsodd of a grayscale image.
@param input  A 2d array containing the input image data.
@param derivative_bound_policy
The convolution boundary handling policy for derivative  computation.
@param smooth_options  The specified smoothing options.
@param use_double_convolution
A boolean value to indicate if to use double convolution or not.
@param result  A 2d array to store the result mmsodd value.

@details
This function is used to get the mmsodd of a grayscale image.

If use_double_convolution is true, this function will smooth the input image
first in one convolution, then convolve the smoothed image with derivative
filter in a second convolution.
If use_double_convolution is false, this function will convolve the smooth filter
and derivative filter first to produce a horzontal filter and a vertical filter,
and then convolve with the input image in one convolution.
*/
void get_mmsodd_grayscale(const SPL::Array2<double>& input,
                          int derivative_bound_policy,
                          const Smooth_options& smooth_options,
                          bool use_double_convolution,
                          SPL::Array2<double>& result);


/*!
@brief  Get the magnitude of laplacian of a grayscale image.
@param input  A 2d array containing the input image data.
@param derivative_bound_policy
The convolution boundary handling policy for derivative computation.
@param smooth_options  The specified smoothing options.
@param use_double_convolution
A boolean value to indicate if to se double convolution or not.
@param result  A 2d array to store the result mmsodd value.

@details
This function is used to get the magnitude of laplacian of a grayscale image.

If use_double_convolution is true, this function will smooth the input image
first in one convolution, then convolve the smoothed image with laplacian filter
in a second convolution.
If use_double_convolution is false, this function will convolve the smooth filter
and laplacian filter first to produce a horzontal filter and a vertical filter,
and then convolve with the input image in one convolution.
*/
void get_mag_laplacian_grayscale(const SPL::Array2<double>& input, int derivative_bound_policy,
                             const Smooth_options& smooth_options, bool use_double_convolution,
                             SPL::Array2<double>& result);

/*!
@brief  Get the maximum directional gradient (mdg) of a rgb color image.
@param input
A vector of 2d array containing the image data of r, g, b components.
@param derivative_bound_policy
The convolution boundary handling policy for derivative  computation.
@param smooth_options  The specified smoothing options.
@param use_double_convolution
A boolean value to indicate if to se double convolution or not.
@param result  A 2d array to store the result mmsodd value.

@details
This function uses the vector gradient operator method of Di Zenzo to compute
the maximum directional gradient of a color image.

If use_double_convolution is true, this function will smooth the input image
first in one convolution, then convolve the smoothed image with derivative filter
in a second convolution.
If use_double_convolution is false, this function will convolve the smooth filter
and derivative filter first to produce a horzontal filter and a vertical filter,
and then convolve with the input image in one convolution.
*/
void get_mdg_color(const std::array<SPL::Array2<double>, 3>& input,
                      int derivative_bound_policy,
                      const Smooth_options& smooth_options,
                      bool use_double_convolution,
                      SPL::Array2<double>& result);



/**************************************************************************

The following shows the definition of some function templates.

***************************************************************************/

template <class I>
void random_shuffle(I begin, I end, unsigned int seed)
{
  std::mt19937 g(seed);
  std::shuffle(begin, end, g);
}

template <typename T>
T generate_random_number(T lower_bound, T upper_bound, unsigned int seed)
{
  std::mt19937 g(seed);
  std::uniform_real_distribution<T> distribution(lower_bound, upper_bound);
  return distribution(g);
}

template <class T, class F>
void for_each_face_in_region(T& tri,
                             std::set<typename T::Halfedge_handle>& border_edges,
                             F func)
{
  // s is just an alias of border_edges
  std::set<typename T::Halfedge_handle>& s = border_edges;
  while (!s.empty()) {
    typename T::Halfedge_handle h = *(s.begin());
    s.erase(h);

    if (s.find(h->next()) != s.end()) {
      s.erase(h->next());
    } else {
      s.insert(h->next()->opposite());
    }

    if (s.find(h->prev()) != s.end()) {
      s.erase(h->prev());
    } else {
      s.insert(h->prev()->opposite());
    }

    func(h->face());
  }
}

#endif




